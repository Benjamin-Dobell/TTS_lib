-- ~~~~~~
-- Script by dzikakulka
-- Issues, history at: http://github.com/tjakubo2/TTS_lib
--
-- Misc functions for extending Lua functionality
-- Description and usage in README.md in this lib folder in repository
-- ~~~~~~

-- Return value limited by min and max bounds
math.clamp = function(var, min, max)
    if min and var < min then
        return min
    elseif max and var > max then
        return max
    end
    return var
end

-- Sign function, zero for zero
math.sgn = function(arg)
    if arg < 0 then
        return -1
    elseif arg > 0 then
        return 1
    end
    return 0
end

-- Round to decPlaces decimal places
-- if decPlaces nil round to nearest integer
math.round = function(arg, decPlaces)
    if decPlaces == nil then decPlaces = 0 end
    if decPlaces == 0 then
        frac = arg - math.floor(arg)
        if frac >= 0.5 then
            return math.ceil(arg)
        else
            return math.floor(arg)
        end
    else
        local mult = 10^(decPlaces or 0)
        return math.floor(arg * mult + 0.5) / mult
    end
end

-- Check if table is empty
table.empty = function(tab)
    return (next(tab) == nil)
end

-- Shallow table copy
-- Does not include metatables
table.shallowcopy = function(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in pairs(orig) do
            copy[orig_key] = orig_value
        end
    else
        copy = orig
    end
    return copy
end

-- Deep table copy
-- Includes metatables, avoids __pairs, recursive
table.deepcopy = function(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[table.deepcopy(orig_key)] = table.deepcopy(orig_value)
        end
        if getmetatable(orig) then
            setmetatable(copy, table.deepcopy(getmetatable(orig)))
        end
    else
        copy = orig
    end
    return copy
end

-- Check if string begins with the argument (no regex)
string.beginswith = function(str, prefix)
    return (str:sub(1, prefix:len()) == prefix)
end
string.startswith = string.beginswith

-- Check if the string ends with the argument (no regex)
string.endswith = function(str, prefix)
    return (str:sub(-1*prefix:len(), -1) == prefix)
end

-- CHeck if string contains argument anywhere in it (no regex)
string.contains = function(str, query)
    return (str:find(query, 1, true) ~= nil)
end
